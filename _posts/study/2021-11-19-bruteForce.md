---
published: false
---
알고리즘을 생각하는 것은 까다롭움
복잡한 요구사항 프로그램을 할 때 감이 오지 않는 경우와 깊이 생각 안하고 타이핑을 하였다가 꼬여버리는 코드를 고치는 경험도 있음

알고리즘 고안
- 해결할 문제의 특성을 이해
- 동작 시간과 사용하는 공간 사이의 상충 관계를 이해
- 적절한 자료 구조를 선택

무식하게 풀기
6-1
가장 많이 하는 실수
쉬운 문제를 어렵게 푸는 것
공부를 열심히 할수록 복잡하지만 우아한 답안을 만들고 싶은 마음이 커지기 마련이고, 바로 앞에 보이고 쉽고 간단하게 틀릴 가능성이 낮은 답안을 간과하기 쉬움

실수 방지
무식하게 풀 수 있을까?
무식하게 푼다(brute-force)는 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법을 의미
ex 두 점 사이의 최단 경로를 찾는 문제, 자원을 분배할 수 있는 경우의 수

가능한 방법을 전부 만들어 보는 알고리즘을 완전 탐색(exhaustive search)이라고 함

## 6.2 재귀 호출과 완전 탐색
재귀 호출
컴퓨터가 수행하는 많은 작업들은 대개 작은 조각들로 나누어 볼 수 있다.
들여다보는 범위가 작아지면 각 조각들의 형태가 유사해지는 작업들을 많이 볼 수 있다. 완전히 같은 코드를 반복해 실행하는 for같은 반복문이 좋은 예이다.
이 작업을 구현할 때 유용하게 사용되는 개념이 재귀 함수(recursive function)과 재귀 호출(recursion)이다. 재귀 함수란 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수를 가린다.

1부터 n까지의 합을 계산하는 반복 함수와 재귀 함수
```c++
필수 조건: n>=1
결과: 1부터 n까지의 합을 반환한다.

//반복 함수
int sum(int n){
	int ret = 0;
	for (int i = 1 ; i <= n ; ++i)
		ret += 1;
	return ret;
}

//재귀 함수
int recursiveSum(int n){
	if (n == 1) return 1;
	return n + recursiveSum(n - 1);
}
```
모든 재귀 함수는 더 이상 **쪼개지지 않는** 최소한의 작업에 도달했을 때 답을 반환하는 조건문을 포함해야 한다. 이를 재귀 호출의 기저 사례(base case)라고 한다.

### 중첩 반복문 대체하기
0번부터 차례대로 번호 매겨진 n개의 원소중 4개를 고르는 모든 경우를 출력하는 코드를 작성하자. n = 7이라면 (0, 1, 2, 3) (0, 1, 2, 4) ... (3, 4, 5, 6)의 모든 경우를 출력해야 함

```c++
for (int i = 0 ; i < n ; ++i)
	for (int j = i + 1 ; j < n ; ++j)
     	for (int k = j + 1 ; k < n ; ++k)
			for (int l = k + 1 ; l < n ; l++)
				cout << i << ' ' << j << ' ' << k << ' ' << l << endl;
```
만약 5개를 골라야 한다면? -> 5중 for문을 사용
만약 6개를 골라야 한다면? -> 6중 for문을 사용
.
.
.
만약 x개를 골라야 한다면? -> x중 for문을 사용
골라야할 원소의 수가 입력에 따라 달라질 수 있는 경우에는 사용할 수 없지만, 재귀 호출은 이런 경우에 단순한 반복문 보다 간결하고 유연한 코드를 작성할 수 있도록 도와준다

위 코드 족각이 하는 작업은 네 갸의 조각으로 나눌 수 있다. 각조각에서 하나의 원소를 고르고, 이렇게 원소를 고른 뒤, 남은 원소들을 고르는 작업을 자기 자신을 호출해 떠넘기는 재귀 함수를 작성.

남은 원소들을 고르는 작업 정의
- 원소들의 총 개수
- 더 골라야 할 원소들의 개수
- 지금까지 고른 원소들의 번호


```c++
n개의 원소 중 m개를 고르는 모든 조합을 찾는 알고리즘
void pick(int n, vector<int>& picked, int toPick) {
 	if (toPick == 0) { printPicked(picked); return ; }
  	for (int next = smallest ;  next < n ; ++next) {
     	picked.push_back(next);
      	pick(n, picked, toPick - 1);
      	picked.pop_back();
    }
}
```
그림 나중에 추가

